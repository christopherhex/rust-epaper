pub mod epaper_test {

  use std::error::Error;
  use std::thread;
  use std::time::Duration;

  use rppal::spi::{Bus, Mode, Segment, SlaveSelect, Spi};
  use rppal::gpio::{Gpio, InputPin, OutputPin};

  const RST_PIN   : u8 = 21;
  const DC_PIN    : u8 = 25;
  const CS_PIN    : u8 = 8;
  const BUSY_PIN  : u8 = 24;

  const EPD_WIDTH : i32 = 176;
  const EPD_HEIGHT : i32 = 264;

  const LUT_VCOM_DC : [u8;44] = [0x00, 0x00,
    0x00, 0x08, 0x00, 0x00, 0x00, 0x02,
    0x60, 0x28, 0x28, 0x00, 0x00, 0x01,
    0x00, 0x14, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x12, 0x12, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  ];

  const LUT_WW : [u8; 42] = [
    0x40, 0x08, 0x00, 0x00, 0x00, 0x02,
    0x90, 0x28, 0x28, 0x00, 0x00, 0x01,
    0x40, 0x14, 0x00, 0x00, 0x00, 0x01,
    0xA0, 0x12, 0x12, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  ];

  const LUT_BW  : [u8; 42] = [
    0x40, 0x08, 0x00, 0x00, 0x00, 0x02,
    0x90, 0x28, 0x28, 0x00, 0x00, 0x01,
    0x40, 0x14, 0x00, 0x00, 0x00, 0x01,
    0xA0, 0x12, 0x12, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  ];

  const LUT_BB : [u8; 42] = [
    0x80, 0x08, 0x00, 0x00, 0x00, 0x02,
    0x90, 0x28, 0x28, 0x00, 0x00, 0x01,
    0x80, 0x14, 0x00, 0x00, 0x00, 0x01,
    0x50, 0x12, 0x12, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  ];

  const LUT_WB : [u8; 42] = [
    0x80, 0x08, 0x00, 0x00, 0x00, 0x02,
    0x90, 0x28, 0x28, 0x00, 0x00, 0x01,
    0x80, 0x14, 0x00, 0x00, 0x00, 0x01,
    0x50, 0x12, 0x12, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  ];

  const GRAY_LUT_VCOM : [u8; 44] = [
    0x00, 0x00,
    0x00, 0x0A, 0x00, 0x00, 0x00, 0x01,
    0x60, 0x14, 0x14, 0x00, 0x00, 0x01,
    0x00, 0x14, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x13, 0x0A, 0x01, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,				
  ];

  const GRAY_LUT_WW : [u8; 42] =[
    0x40, 0x0A, 0x00, 0x00, 0x00, 0x01,
    0x90, 0x14, 0x14, 0x00, 0x00, 0x01,
    0x10, 0x14, 0x0A, 0x00, 0x00, 0x01,
    0xA0, 0x13, 0x01, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  ];

  const GRAY_LUT_BW : [u8; 42] =[
    0x40, 0x0A, 0x00, 0x00, 0x00, 0x01,
    0x90, 0x14, 0x14, 0x00, 0x00, 0x01,
    0x00, 0x14, 0x0A, 0x00, 0x00, 0x01,
    0x99, 0x0C, 0x01, 0x03, 0x04, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  ];

  const GRAY_LUT_WB : [u8; 42] =[
    0x40, 0x0A, 0x00, 0x00, 0x00, 0x01,
    0x90, 0x14, 0x14, 0x00, 0x00, 0x01,
    0x00, 0x14, 0x0A, 0x00, 0x00, 0x01,
    0x99, 0x0B, 0x04, 0x04, 0x01, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  ];

  const GRAY_LUT_BB : [u8; 42] = [
    0x80, 0x0A, 0x00, 0x00, 0x00, 0x01,
    0x90, 0x14, 0x14, 0x00, 0x00, 0x01,
    0x20, 0x14, 0x0A, 0x00, 0x00, 0x01,
    0x50, 0x13, 0x01, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  ];

  struct RpiGpioConfig {
    reset: OutputPin, 
    dc: OutputPin,
    cs: OutputPin,
    busy: InputPin
  }

  struct RaspiPaper {
    config: RpiGpioConfig,
    spi: Spi
  }

  impl RaspiPaper {

    fn new() -> RaspiPaper {
      let gpio_inst = Gpio::new().unwrap();

      let config = RpiGpioConfig {
        reset: gpio_inst.get(RST_PIN).unwrap().into_output(),
        dc: gpio_inst.get(DC_PIN).unwrap().into_output(),
        cs: gpio_inst.get(CS_PIN).unwrap().into_output(),
        busy: gpio_inst.get(BUSY_PIN).unwrap().into_input()
      };

      let mut spi = Spi::new(Bus::Spi0, SlaveSelect::Ss0, 4_000_000, Mode::Mode0).unwrap();

      // Return RaspiPaper Struct
      return RaspiPaper {
        config,
        spi
      };
    }

    pub fn reset(&mut self) -> () {

      self.config.reset.set_high();
      thread::sleep(Duration::from_millis(200));
      self.config.reset.set_low();
      thread::sleep(Duration::from_millis(10));
      self.config.reset.set_high();
      thread::sleep(Duration::from_millis(200));
      
    }

    pub fn init(&mut self) -> () {
      // Reset
      self.reset();
      
      self.send_command(0x01); 
      self.send_data(0x03); 
      self.send_data(0x00); 
      self.send_data(0x2b); 
      self.send_data(0x2b); 
      self.send_data(0x09);
      
      self.send_command(0x06);
      self.send_data(0x07);
      self.send_data(0x07);
      self.send_data(0x17);
      
      self.send_command(0xF8);
      self.send_data(0x60);
      self.send_data(0xA5);
      
      self.send_command(0xF8);
      self.send_data(0x89);
      self.send_data(0xA5);
      
      self.send_command(0xF8);
      self.send_data(0x90);
      self.send_data(0x00);
      
      self.send_command(0xF8);
      self.send_data(0x93);
      self.send_data(0x2A);
      
      self.send_command(0xF8);
      self.send_data(0xA0);
      self.send_data(0xA5);
      
      self.send_command(0xF8);
      self.send_data(0xA1);
      self.send_data(0x00);
      
      self.send_command(0xF8);
      self.send_data(0x73);
      self.send_data(0x41);
      
      self.send_command(0x16);
      self.send_data(0x00);
      self.send_command(0x04);
      self.read_busy();

      self.send_command(0x00);
      self.send_data(0xAF);
      
      self.send_command(0x30);
      self.send_data(0x3A);
      
      self.send_command(0x82);
      self.send_data(0x12);
      self.set_lut()
    }

    pub fn set_lut(&mut self) {
      self.send_command(0x20);
      for count in 0..44 {
        self.send_data(LUT_VCOM_DC[count]);
      }
      self.send_command(0x21);
      
      for count in 0..42 {
        self.send_data(LUT_WW[count]);
      }


      self.send_command(0x22);

      for count in 0..42 {
        self.send_data(LUT_BW[count]);
      }

      self.send_command(0x23);
      
      for count in 0..42 {
        self.send_data(LUT_BB[count]);
      }

      self.send_command(0x24);
      
      for count in 0..42 {
          self.send_data(LUT_WB[count]);
      }

    }

    pub fn read_busy(&mut self){
      println!("CHECK BUSY");
      while self.config.busy.is_low() {
        thread::sleep(Duration::from_millis(200));
      }
      println!("RELEASE BUSY");
    }
    pub fn send_command(&mut self, data: u8){
      self.config.dc.set_low();
      self.config.cs.set_low();
      // Write Byte
      self.spi.write(&[data]).unwrap();
      self.config.cs.set_high();

    }

    pub fn send_data(&mut self, data: u8){
      self.config.dc.set_high();
      self.config.cs.set_low();
      // Write Byte
      self.spi.write(&[data]).unwrap();
      self.config.cs.set_high();

    }

    pub fn clear_screen(&mut self){
      self.send_command(0x10);
      for i in 1..5808 {
        self.send_data(0xFF);
      }
      self.send_command(0x13);
      for i in 1..5808 {
        self.send_data(0xFF);
      }
      self.send_command(0x12);
      self.read_busy();
    }

    fn convert_buffer(&mut self, image: &Vec<u8>) -> Vec<u8> {

      let len = (EPD_WIDTH * EPD_HEIGHT / 8) as usize;
      let mut shrinked_vec : Vec<u8> = vec![0;len];

      for i in 0..image.len() {

        let key = i / 8;
        let key2 = i % 8;

        if(image[i as usize] < 255){
          shrinked_vec[key] = shrinked_vec[key]|(0x80 >> key2);
        }

      }

      return shrinked_vec;
    }

    pub fn display(&mut self, image: &Vec<u8>){

      let other_image = self.convert_buffer(image);

      println!("dimensions {:?}", other_image);


      self.send_command(0x10);
      for i in 0..(EPD_WIDTH * EPD_HEIGHT / 8) {
          self.send_data(0xFF)
      }

      self.send_command(0x13);
   
      for i in 0..(EPD_WIDTH * EPD_HEIGHT / 8){
        self.send_data(other_image[i as usize]);
      }
          
      self.send_command(0x12) ;
      self.read_busy();
  
    }

  }




  pub fn inittest(image: &Vec<u8>)  {

    println!("Before RaspiPaper");
    let mut raspi_paper = RaspiPaper::new();
    println!("After RaspiPaper");
    raspi_paper.init();
    println!("Before Display");
    raspi_paper.display(image);
    println!("After Display");

    thread::sleep(Duration::from_secs(10));

    println!("After Reset");
    raspi_paper.clear_screen();
    println!("Cleared screen");

  }
}